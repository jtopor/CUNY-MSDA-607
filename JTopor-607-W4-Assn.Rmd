---
title: "CUNY MSDA 607 Week 4 Assignment"
author: "James Topor"
output: html_document
---

Problems 3, 7, and 8 from chapter 8 of Automated Data Collection in R
         and Problem 9 for extra credit

# -------------------------------------------------------------------------

__3.__ 

```{r}
library(stringr)

# Create text containing names and phone numbers of Simpsons characters
raw.data <- "555-1239Moe Szyslak(636) 555-0113Burns, C. Montgomery555-6542Rev. Timothy Lovejoy555 8904Ned Flanders636-555-3226Simpson,Homer5553642Dr. Julius Hibbert"

# extract names
name <- unlist(str_extract_all(raw.data, "[[:alpha:]., ]{2,}"))
name

```

__a)__ Use the tools of this chapter to rearrange the vector so that all elements conform to the standard "firstname lastname".

The following R code rearranges the vector to "firstname lastname" format by first checking a vector element for the presence of a comma ",". If a comma is detected the vector element is split using the comma as the split delimeter. The results of the split are then reordered and replace the original vector element.  
```{r}
# for each element in the vector of names
for(i in 1:length(name)) {

  # if a comma is detected, split the vector
  if (str_detect(name[i], ",") == TRUE) {
    namelist <- str_trim(unlist(strsplit(name[i], ",")))
    # reorder the results of the split and update the vector element
    name[i] = str_c(namelist[2], " ", namelist[1])
  } # end if
  
} # end for

name

```

__b)__ Construct a logical vector indicating whether a character has a title (i.e., Rev. and Dr.).

We can use R's __grep1__ function to test a vector for the presence of multiple substrings. For this problem, we set up a string containing the titles we want to check for and delimit them by the "|" character (indicating a logical "OR"). We then submit that string and the 'name' vector to the __grep1__ function to get the required logical vector.  
```{r}
titles <- "Dr.|Rev."

grepl(titles, name)
```

__c)__ Construct a logical vector indicating whether a character has a second name.

To check for a second name we first need to know whether a vector element contains a title. We then need to check each vector element for the presence of more than 2 other substrings. If we find more than 2 additional substrings after accounting for titles, we know we've found a character that has a second name.

```{r}
# create a logical vector indicating whether character has a title
titles <- "Dr.|Rev."
titlebool <- grepl(titles, name)

# create a logical vector to store the results of the second name search
secondname <- logical(length(name))

# for each element in the vector of names
for(i in 1:length(name)) {

  # if character has a title, check for > 3 substrings
  if (titlebool[i] == TRUE) {
    if (length(unlist(strsplit(name[i], " "))) > 3) {
      secondname[i] <- TRUE
    }
      
  } else { # else character doesn't have title so check for > 2 substrings
      if (length(unlist(strsplit(name[i], " "))) > 2) {
        secondname[i] <- TRUE
      }
  }
  
} # end for

secondname

```

# ------------------------------------------------------------------------
__7.__ 

The expression <.+> fails because the period character "." is considered a wildcard in this context and the plus character "+" basically says 'match the preceding one or more times'. As such, the regular expression is evaluated as follows:  

1) First look for a "<" character;  

2) Then, since we have a wildcard,  accept any character that follows the "<";  

3) Then the "+" says "accept anything that matches the preceding". Since the preceding argument in the regular expression is a ".", any character found will be added to our output string;  

4) Then continue "matching" the wildcard until a ">" is found that has no additional characters following it.  

Therefore, the 'str_extract' function will ignore the first ">" character it encounters and continue parsing the input string until the last ">" is found.

The correct expression should include a "?" character after the "+". Including the "?" character changes its interpretation to mean: 'only look for the shortest possible sequence of any characters before a ">" character'. As such, __the proper expression is "<.+?>"__. This will cause the parsing process to terminate once the first ">" character is located.   

An R code chunk demonstrating both the incorrect and correct regular expressions is given here:  
```{r}
tempstr <- "<title>+++BREAKING NEWS+++</title>"

# improper regex for the result we want
str_extract(tempstr, "<.+>")

# correct regex for the result we want
str_extract(tempstr, "<.+?>")
```

# ------------------------------------------------------------------------
__8.__ Consider the string '(5-3)\^2=5\^2-2\*5\*3+3\^2' conforms to the binomial theorem. We would like to extract the formula in the string. To do so we write the regular expression [^0-9=+*()]+. Explain why this fails and correct the expression.

The "^" character inverts the contents of a class, so all characters EXCEPT those matching those included in the class will be matched. Also, we are missing a minus sign "-" from our list of mathematical characters to be included in the output of the 'str_extract' function.

The correct expression is [\\\\^0-9-=+*()]+. We need to preceed the "^" character with a double backslash to force the 'str_extract' function to interpret the character as-is rather than treating it as a command to invert the class.  

We also need to ensure that the "-" character is maintained within the class so that it won't be excluded from the results.

An R code chunk demonstrating both the incorrect and correct regular expressions is given here:  
```{r}
tempstr <- "(5-3)^2=5^2-2*5*3+3^2"

# improper regex for the result we want
str_extract(tempstr, "[^0-9=+*()]+")

# correct regex for the result we want
str_extract(tempstr, "[\\^0-9-=+*()]+")
```

We can also generate the correct output using the following:
```{r}
# two more examples of correct regex arguments for this problem
str_extract(tempstr, "[\\^\\d-=+*()]+")

str_extract(tempstr, "[\\^[:digit:]-=+*()]+")
```

Personally, I prefer either of these two solutions to the first one since, for me, they are easier to interpret due to the explicit, bounded nature of the digits arguments used in each.

# ------------------------------------------------------------------------
__9.__ Find the hidden message in the string:

```{r}
tempstr <- "clcopCow1zmstc0d87wnkig7OvdicpNuggvhryn92Gjuwczi8hqrfpRxs5Aj5dwpn0TanwoUwisdij7Lj8kpf03AT5Idr3coc0bt7yczjatOaootj55t3Nj3ne6c4Sfek.r1w1YwwojigOd6vrfUrbz2.2bkAnbhzgv4R9i05zEcrop.wAgnb.SqoU65fPa1otfb7wEm24k6t3sR9zqe5fy89n6Nd5t9kc4fE905gmc4Rgxo5nhDk!gr"

unlist(str_extract_all(tempstr, "[[:upper:].!]"))
```

The hidden message is: "CONGRATULATIONS. YOU. ARE. A. SUPERNERD!".