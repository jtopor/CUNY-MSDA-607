---
title: "CUNY MSDA 607 Spring 2016 Project 1"
author: "James Topor"
date: "February 15, 2016"
output: html_document
---

The purpose of this script is to read a text file with chess tournament results and create an R Markdown file that generates a .CSV file with the following information for all of the players:

- Player's Name  
- Player's State  
- Total Number of Points   
- Player's Pre-Rating  
- Average Pre Chess Rating of Opponents   

For example, for the first player the information would be:
Gary Hua, ON, 6.0, 1794, 1605  

The 1605 figure is calculated by using the pre-tournament opponents' ratings of 1436, 1563, 1600, 1610, 1649, 1663, 1716, and dividing by the total number of games played.

### Exploring the Chess Tournament Results

We'll start by reading the text file that contains the results of the chess tournament and displaying the first and last 20 lines of the file:

```{r, warning=FALSE}
# sample code to remove a subset of lines from a character vector
# proclines <- lines[-(i)]

library(stringr)

path <- "https://raw.githubusercontent.com/jtopor/CUNY-MSDA-607/master/tournamentinfo.txt"
conn <- file(path,open="r")
lines <- readLines(conn)

# close the file before proceeding
close(conn)

# display the first 20 lines
head(lines, n=20)

# display last 20 lines
tail(lines, n=20)
```


The text file appears to have a significant amount of fixed structure. For example: 

- The second and third lines provide header information for the various columns within the text;  

- Information for each individual players is summarized within two consecutive lines of the file;  

- Pertinent player attributes appear to be located at fixed offsets from the start of a line;  

- Columns within the text are delineated by '|' characters; etc.

We can make use of this embedded structure to help us extract the relevant items we require for creation of the .csv file we have been asked to create.

Upon review of the contents of the text file we can summarize the information available for each of the attributes we are concerned with as follows:

- __Player's Name__: The player's name is provided on the first line of data for a given player and conforms to the "Firstname Lastname" format. It appears to be limited to a fixed number of characters as evidenced by the format of the file. The player's name is immediately preceded by several characters, including several blank spaces, the player's ID number for the tournament, and the sequence "(space)|(space) " where (space) indicates a blank space.

- __Player's State__: The player's state is given toward the start of the second line of data for a given player. The state identifier is two characters in length and is immediately preceded by what appears to be a fixed number of blank spaces.

- __Total Number of Points__: The total number of points is given on the first line of data for a given player following the player's name and immediately preceded by the '|' character. The point count is given as a two digits separated by a decimal point (e.g., "5.5"). 

- __Player's Pre-Rating__: The player's pre-rating is provided on the second line of data for a given player and is immediately preceded by the sequence "R:" followed by one or more blank spaces. The rating itself is an integer having up to 4 digits. As we can see from the output of R's __tail__ function above, several players have ratings whose values are only 3 digits in length, with the leading fourth digit having been replaced by a blank space.

- __Average Pre Chess Rating of Opponents__: The average pre chess rating of opponents is a metric we'll need to calculate based on data contained within the file. As we can see from the text file, the chess tournament consisted of seven separate rounds of play. Each individual player's results for the various rounds are provided within the first line of data for a given player, with a "W" indicative of a win, a "D" indicative of a draw, and a "L" indicating that the player was beaten by their opponent. Each "W/L/D" indicator is immediately preceded by a "|" character and is followed by one or more spaces and the ID number of the player's opponent. To calculate the average pre chess rating of opponents we'll need to locate each opponent's Pre-Rating, sum them, and divide by the number of games played by the player of interest. It is important to note that not every player participated in each of the seven rounds; as we can see, particularly in the output of R's __tail__ function above, numerous players either received "byes" for a round (as indicated by a "B" in the "W/L/D" field) or were unable to compete (as indicated by a "U" in the "W/L/D" field). We'll need to account for such instances when attempting to calculate the required average pre chess rating metric.


### Removing Extraneous Formatting from the Text File Data
The text file contains numerous lines filled with nothing but hyphens ('-'). Those lines make the text file easier to read but don't really add any useful information to the contents of the file. Similarly, the second and third lines provide only header data and aren't truly required for our task here. While they do provide names for the various columns within the text file, we can't easily discern the entirety of any column name based on the content of a single line of text within the file, and some columns names are spread across multiple lines of text within the file (e.g., "Total Pts"). Any attempt at writing an automated routine to extract the column names would likely result in application code that would be overly specific to this one file and therefore of limited use for other applications.

Furthermore, since we've already had to visually discern the structure of the file for purposes of constructing an algorithm to generate the results we seek, the header lines add no further value going forward and can be discarded. Therefore, we can simply remove both the hyphen-filled lines and the two header lines from our data to simplify our processing a bit:

```{r}
# create an empty character vector for processing
proclines <- character()

# set counter for index of proclines vector
j <- 1

# skip the first three lines and remove any line that begins with three hyphens
for(i in 4:length(lines)) {

  # if a '---' is not detected, add line to proclines
  if (str_detect(lines[i], "---") == FALSE) {
    proclines[j] <- lines[i]
    j <- j+1
  } # end if
  
} # end for

# display refined data
head(proclines, n=10)
tail(proclines, n=10)
```


### Extracting the Required Data Fields from the Refined Text File Data
Our refinements to the initial text file data allow us to now proceed with our efforts to construct the required .csv file. We'll start by first calculating the number of chess players represented by our data and pre-allocating a data frame to house the results of our data extraction efforts. Since we've already visually determined that each player is represented by two rows of text file data we can simply find the total number of lines remaining in our refined data set and divide that total by two. Our result is then used to pre-allocate the required data frame:

```{r]}
# calculate the number of players: we have 2 lines per player
n <- length(proclines)/2

# pre-allocate a dataframe to house the items needed for the csv file
csv_df <- data.frame(PlayerName = character(n), State = character(n), TotPts = numeric(n), PreRate = numeric(n), AvgPreRate = numeric(n), stringsAsFactors = FALSE)

# pre-allocate a list of lists to house ID numbers of each player's opponents
opponents <- list()
```

Pre-allocating the dataframe is much more efficient computationally than incrementally adding individual rows to an existing data frame. The pre-allocation will allow us to simply update the relevant elements of the data frame as we locate the required player attributes.

As we discussed earlier, there are 5 separate attributes we need to find for each player. Of these, four (name, state, total points, pre-rating) are given explicitly within the two rows pertaining to an individual player. The fifth (average pre-rating of opponent) is not given explicitly and needs to be calculated. Therefore, our approach to populating the data frame we'll use to generate the required .csv file will require at a minimum two separate iterations through the chess tournament data:

- First, we'll need to extract the four explicitly provided items for each player as well as the ID numbers of the various opponents they competed against during the seven round tournament;  

- Then we'll iterate through our list of players and for each one we'll "look up" the pre-ratings of each of their opponents and calculate the average pre-rating for that group.

To facilitate faster processing, we'll make use of the fact that the attributes we seek are located at fixed offsets within the text file data. Therefore, we can search through one player's data to find all of the relevant attribute offsets and then use those fixed offsets throughout our efforts to extract the relevant items from the remaining players listed in the text file data. This "fixed offset" approach drastically reduces the amount of CPU time required to create the required .csv file since we won't need to apply regular expressions to every character within the original data. 

The following code finds fixed offsets we can use to extract the pertinent data. The first line of data for each player relies on '|' characters to delimit the various columns of data. We therefore find the location of each of these characters within that line and use those locations as offsets to search for 'player name', 'total points', and the ID numbers of each of their opponents. The locations of the 'state' and 'pre-rating' items are found via other delimiters within the second line of a player's data.  
```{r}
# find delimeter locations in first line of player data - should be 10 in total
# these will be used to parse for player name, total points, and opponent ID numbers
temp <- str_locate_all(proclines[1], "\\|")

# move read pointers to one character beyond '|' for all '|' found above
delims_1 <- temp[[1]][,1] + 1

# ---------------------------------------------------------------------------
# find location of state code within the second line
temp <- str_locate(proclines[2], "[:alpha:]")

state_offset <- temp[1]

# ---------------------------------------------------------------------------
# find location of pre-rating within the second line
temp <- str_locate(proclines[2], ":")

# move read pointer to one character beyond ':' to enable access to pre-rate value
prerate_offset <- temp[1] + 1
```


Now that we've calculated the fixed offsets required for extracting the pertinent data, our first iteration through the text file data will extract player name, total points, state, pre-rating, and the list of each player's opponents.

```{r}
# now for each player, extract name, total points, list of opponents, state, and pre-rate

for(i in 1:n) {

  # extract name - name is found near first offset in line 1
  csv_df$PlayerName[i] <- str_trim(str_extract(str_sub(proclines[(2*i)-1], start = delims_1[1] ),
                                               "[[:alpha:][:blank:]]+"))
  
  # --------------------------------
  # extract total points - is found near second offset in line 1
  csv_df$TotPts[i] <- as.numeric(str_extract(str_sub(proclines[(2*i)-1], start = delims_1[2]), "[[:digit:].]+"))
  
  # --------------------------------  
  # extract state - is found at fixed location on 2nd line
  csv_df$State[i] <- str_extract(str_sub(proclines[(2*i)], start = state_offset), "[:alpha:]+")
  
  # --------------------------------
  # extract pre-rate - is found near offset value on 2nd line
  csv_df$PreRate[i] <- as.numeric(str_extract(str_sub(proclines[(2*i)], start = prerate_offset), "[:digit:]+"))

  # --------------------------------
  # extract list of opponents - use offsets 3 through 9 from first line of player data to locate the ID numbers
  # initiate the list of opponenets for player 'i'
  opp_list <- numeric()
  
  # j is a counter for the list of opponents for a specific player
  j <- 1
  
  for(k in 3:9) {
    wld <- str_extract(str_sub(proclines[(2*i)-1], start = delims_1[k]), "[:alpha:]")
    
    # check for char == W/L/D, if != then skip to next delimeter 
    if (wld == 'W' | wld == 'L' | wld == 'D') {
      # read the opponent ID number and add it to the player's list of opponents
      opp_list[j] <- as.numeric(str_extract(str_sub(proclines[(2*i)-1], start = delims_1[k]), "[:digit:]+"))
      
      # increment the counter for number of opponents found for the player
      j <- j+1
    } # end if wld
  } # end for k in 3:9
  
  # add the player's list of opponents to the list of all player's lists of opponents
  opponents <- append(opponents, list(opp_list))
  
} # end for i in 1:n

head(csv_df, n=20)
```

As we can see from the above, we now have nearly all of the required items for the .csv file. The only item missing from our data frame is the average pre-rating of opponents. As mentioned earlier, we need to calculate that average ourselves based on the data we've extracted from the text file. We've identified each player's opponents during our extraction work above. We now have a list of each player's opponents in a format with which we can perform calculations. Here's a sample of our lists of opponents:

```{r}
head(opponents, n=20)
```

Our task now is to match the pre-rating of each player's opponents to the ID numbers we've accummulated within the lists of each player's opponents. The pre-ratings will be summed and averaged, thereby providing the last element we require for the .csv file we are tasked with creating.

### Calculating the Average Pre-Rating of Each Player's Opponents
The lists of opponents were created such that the sequence of the lists matches the order of the items we've added thus far to our data frame. The data frame is ordered by the ID numbers of the individual players. Therefore, we can loop through both the data frame and the list of opponent lists simultaneously to calculate the required averages.

```{r}

for(i in 1:nrow(csv_df)) {
  # find the length of the list of opponents for player ID 'i'; this is the number of games played by player 'i'
  listlen <- length(opponents[[i]])
  
  # for each element in the list of opponents, add pre-rating to player's AvgPreRate field
  for(j in 1:listlen) {
    # assign the next opponent ID number to index variable, e.g, opponents[[2]][7] = game 7 opponent of player 2
    op_index <- opponents[[i]][j]
    
    # add opponent's pre-rating to player's AvgPreRate field
    csv_df$AvgPreRate[i] <- csv_df$AvgPreRate[i] + csv_df$PreRate[op_index]
  } # end for j
  
  # divide the player's AvgPreRate field by the number of games played to get the final average pre-rating
  csv_df$AvgPreRate[i] <- round(csv_df$AvgPreRate[i] / listlen)
  
} # end for i

csv_df
```

As we can see above, we now have all of the data required for the .csv file. All that's left to do is write the data frame we've created to a comma delimited output file. 

__NOTE: Please be sure to set the working directory specified in the 'setwd' function call below to reflect your local computing environment.__

```{r}
# set the working directory where you'd like the file written
setwd("c:/SQLData")

# write the csv file
write.csv(csv_df, file="chess.csv", row.names=FALSE, quote = FALSE)
```